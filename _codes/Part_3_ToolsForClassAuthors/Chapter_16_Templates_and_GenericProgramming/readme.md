# <p style = "text-align : center; color : grey">Templates and Generic Programming </p>## Templates :***Templates*** are blueprints from which specific class types and functions are generated by the compiler. This process is known as instantiating, and the class or function generated is know as instantiation.      > template <template_parameter_list> template_name {         >       .../template_definition    > }         > template : keyword used to declare or define template       > template_parameterlist : comma seperated list of template parameters representing **types or non-types** specified inside **angle brackets <>**    > template_name : name of the template       > template_definition : definition which will be either class or function definition.     ### Function templates :      ***Function templates*** are templates from which specific functions will be instantiated     template <template_parameter_list>    ret_type template_name(function_parameter_list) {        .../function body    }**template_parameter_list**, a comma seperated list of one or more template parameters that can be either **type** or **non-type**         **type parameter**, is a name representing a *type* which will be used to declare *function parameter names* or *variables* in the function body. *Types* is declared with **typename** keyword.        **non-type**, is a name representing non-type (ie) a value which is a constant expression. *non-types* are declared by **explicitly** specifiying type of the value         *template parameters* are automatically deduced from the arguments of the call.     **inline and constexpr** can be used in defining function template     ### typename - **typename** keyword is used to declare a name which represents a type.- any no of typename parameters can be declared.    ```c++    ex 1 :-     template <typename T>     T bigger(T a, T b) {        return a > b ? a : b;    }```    - typename is used to declare a name T, which represents a type. type name can be any un-qualified identifier    - T is used to declare the ret-type, function parameters a and b    - when we call the function tempate, T will be deduced from the arguments passed in the call.    - function with T replaced with corresponding type will be instantiated.    - bigger<T> with T replaced with type is the name of the function instantiated, the word "bigger" is function template name. Type deduced is part of the function name.    bigger(34, 24)           ==  T is deduced as int                      ==  int bigger<int>(int a, int b) { ... } is instantiated    bigger(3.4, 2.4)         ==  T is deduced as double               ==  double bigger<double>(double a, double b) { ... }    bigger('c', 'C')         ==  T is deduced as char                      ==  char bigger<char>(char a, char b) { ... }    bigger("hello", "Hello") ==  T is deduced as const char *  ==  const char * bigger<const char *>(const char *a, const char *b) {...}    T can be any type that can passed and returned from a function, like class type, containers etc        ex 2 :-        template <typename T, typename P>         auto bigger(T a, P b) {            return a > b ? a : b;        }     bigger(34, 3.4)       ==  T is int, P is double, ret_type is auto deduced  ==  bigger<int, double>(int a, double b) { ... } ### Implicit type conversion- array to pointer and function to pointer conversion is done implicitly.- a function parameter that is reference or pointer to const can be passed a non-const type.     !!! no other type conversions are possible. normal type conversions that happens in a function call don't happen in template instantiation    bigger(34, 3.4)  //  error : cannot deduce T, int or double  ### Explicit type - Type can be passed to a template by *explicitly* specifying in **angle brackets <>** following the template name before the argument list        ```c++    bigger<int>(34, 3.4)  // ok : T is int, explicitly specified, type of 2nd argument double is converted to int.   ```- when the type is explicitly specified, normal type conversions happens to the arguments in the call to the type specified.### non-type parameters - template parameter can be non-types, (ie) a name which represents a value, but the type of the value should be explicitly mentioned                   ```c++    template <unsigned N, unsigned M>          int bigger(int (&arr)[N], int (&arr)[M]) {              return N > M ? N : M;          }                N,M - names of non-type parameters, though they are both declared to be "unsigned" type, one or more, same or different non-type parameters can be declared.    N, M are used to declare the size of the arrays in the function parameters    bigger(arr1, arr2)  ==  N, M are deduced automatically from the size of the arrays passed in the call    names of the type and non-type parameter can be any un-qualified identifier           template <typename arg_type, typename ret_type>           ret_type bigger(arg_type a, arg_type b) {              return a > b ? 1 : 0;         }            bigger<double, bool>(3.4, 34)       ==      bool bigger(double a, double b) { ... }  is instantiated       ``` ### class template **class template** is a template from which specific class type will be instantiated.     ```c++    tempate <typename type>           class Foo {             ....definition         };   ```   - declared with template keyword- template parameter types are specified inside angle brackets- class template defintion starts with class keyword followed by class template name.- class template body follows then.***unlike*** function templates, type should be **explicitly specified** inside ***angle brackets*** to instantiate- when a class type is instantiated from a template, class template name followed by type inside angle brackets <> forms the class name.```c++             template <typename type>         class Foo {            ...body        };        Foo<int> f1;  Foo<int> is instantiated with int replacing type, f1 is Foo<int> type.  ```- when a class type is instantiated, only the members used in the program will be instantiated     **member definitions outside the class :**- as type is part of the class name, the template parameter list with which class template is defined should be declared - followed by by the class type to which it is a member    ```c++    template <typename type>     ret_type Foo<type>::print() {        ....body    }    ```- template <typename type> : template parameters for the class - ret_type : return type of the member function- `Foo<type>` : class name to which the member belongs- print()  :  member function name- Though type is part of the class name, inside the template definition class name can be used without type as it will be implicitly added by the compiler.    ```c++    template <typename type>     class Foo {        public :            Foo & opertor=(const Foo & rhs) {   //  automatically compiler will replace Foo to Foo<type>                ...//                return *this;            }    };    ```- once the class name is seen, we can use the name with out type, but untill any use should have full name    ```c++    template <typename type>     Foo<type> & Foo<type>::operator=(const Foo & rhs) {        ...//    }    ```### Friendship- One-to-One - One-to-Many- Many-to-one#### One-to-One Friendship Mostly common form of friendship from class template to another template(class or function) is one-to-one (ie) establishes friendship between corresponding instantiations of class and its friend.Inorder to declare a specific instantiation of a class or function as a friend, the template itself needs to be declared first.```c++    ex 1:         template <typename> class Bar;    //  any template declarations includes the template's parameters list, forward declaration of class template Bar        template <typename> ret_type debug(int);    //  forward declaration of debug() function template.        template <typename type>         class Foo {            friend class Bar<T>;        //   declares Bar<T> as a friend to Foo<T>            friend ret_type debug(int); //   declares ret_type debug<T>(int) as a friend to Foo<T>        };        Foo<int> f1;    //  Foo<int> is instantiated, f1 is of Foo<int> type        Bar<int> is a friend of Foo<int>        ret_type debug<int>(int)  is a friend to Foo<int>      ex 2:        template <typename> class Image;        template <typename> class Bar;        template <typename T>        class Foo {            friend class Bar<T>;  // One-to-One  == specific instantiation of Foo declares the specific instantiation of Bar as friend              template <typename P> friend class Sales; // many-to-many == all instances of Foo are friend to all instances of Sales                                                      // when all instances are declared as friend, forward declaration is not needed            friend class Image<int>;  // Many-to-one == any instances of Foo is a friend to Image<int>         };    ex 3:         class Sales {   //  non-template class            template <typename> friend class Bar;   // one-to-many  ==  all instances of Bar is a friend of Sales class        };    ex 4 :         template <typename> ret_type print();        class Sales {            friend ret_type print<Sales>();  //  one-to-one == print function that takes Sales object as template argument is a friend to Sales class.         };```- **type-aliases**, can be declared for class type generated from a template.```c++    ex 1 :-         typedef Blob<string>  StrBlob        typedef Blob<int> iBlob;        StrBlob sb1, sb;        iBlob ib1, ib2;    ex 2 :-        using twin = std::pair<T, T>;         twin<int> t1;   //   t1 is a pair with both first and second members of same int type        twin<double> area;```- **static members**```c++    template <typename T>     class Foo {        public :            static size_t count;    };    template <typename T>     size_t Foo<T>::count = 0;   //  static member definition```- members that are **types**, when we use a member which is a type, we should explicitly tell the compiler that it is a type rather than a static member which is assumed as default    ```c++    template <typename T>     class Foo {        public :        T::mem_name get();   //  error : mem_name is assumed to be a static member of T when accessed through a scope operator        typename T::mem_name get() //  ok : mem_name is a type name defined by T        typedef typename T::size_type index_type;      };    Foo<string>::index_type i;    template <typename T>     typename T::size_type get_size(T val) {        return val.size();    }        ```### Default arguments   Both template parameters and function parameters can have default arguments```c++    template <typename T, typename F = DebugDelete>   // DebugDelete is the default type F represents, if type is not mentioned          class Foo {        .../    }    Foo<int>  ==  Foo<int, DebugDelete> is instantiated    Foo<int, aDeleter> == Foo<int, aDeleter> is instantiated    template <typename T>   //  double is the default type P will represent if it is not mentioned    P bar(T a, T b = 45) {  //  45 is the default value of b        ..../     } ```#### Controlling Instantiations**extern template class Foo<int>;**  tells the compiler that instantiation of Foo<int> will appear somewhere else, so no need to instantiate again.          `Foo<int> f1;`   //  will not be instantiated as instantiation is available some where else        `Foo<double> f2`;  //  `Foo<double>` will be instantiated       **`template class Foo<string>`;**  explicitly instantiates Foo<string> with all members, even members which are not used will be instantiated          large program with multiple files, when a specific instantiation is used in all files, it should be marked extern in all files except one, in which it should be defined      ```c++    extern template Foo<string>;   // template declaration    template Foo<string>;  //  template definition which instantiates Foo<string> with all members```### Type Transformation Library Template classes**remove_reference**, a class template with a public **type** member. when instantiated with a reference type, its type member will be the type of the refered type without reference         ex :-        remove_reference<decltype(rs)>::type s1;  //  if the type of rs is lvalue reference or rvalue reference, its type member will be type of rs.### Reference Collapsingwhen it comes to template, if T is deduced as a reference, and the parameter is declared to be reference of T, then reference collapsing is done.- X& &, X& &&, X&& & all colapses to X&- X&& &&, collapses to X&&reference collapsing is done only when reference to reference is done indirectly in typdefs and templates- A function parameter which is a rvalue reference of the template type parameter, can be bound to a lvalue through reference collapsing.      ```c++    template <typename T>          void print(T &&val) {            ..../         }          print(45)   //  T is int, as 45 is rvalue,          print(num)  //  T is lvalue reference of int, (ie) deduced as int&,  int& &&val == int &val                     //  instantiates void print<int&>(int &val);```#### std::move()  uses referencing collapsing to return an rvalue reference of the argument;```c++    template <typename T>     auto move(T &&val) {        return static_cast<typename remove_reference<T>::type &&>(val);    }```static_cast is used to explicitly convert a lvalue to rvalue reference.```c++    std::move(str1)         str1 - lvalue        T is string, lvalue reference        instantiates std::move<string &>(string &val)   //  through reference collapsing        remove_reference is instantiated with string &, so its type member is string        static_cast casts the type of val from string to string &&.        std::move(string("hello"));        T is string        std::move<string>(string &&val) is instantiated        remove_reference<string>::type is string        static_cast<string &&>(val) returns the val is rvalue reference        return type is rvalue reference.```#### std::forward<T>(val) **std::forward()** is used along with rvalue references to forward the original type of the template arguments to another function.**rvalue reference** parameters of template parameter types preserves lvalueness and constness of the argument.```c++    template <typename T>     void func(T &&val) {        do(val);      }    func(num);  //  T is int&, through reference collapsing , val is of int &    do(val);  //  val is lvalue reference;    func(ci);  //  T is const int&, val is of const int &    do(val);   //  val is const int &     but when we call with the rvalue    func(45);   //  T is int, val is rvalue refernce to int    do(val);  // a variable name is an expression that yields lvalue reference, unable to pass the original type of 45    we loose the rvalueness of the argument. std::forward is used along rvalue reference parameters to preserve the original type of the argument.```**std::forward<T>(val)- through reference collapsing on its return type, it gets the original type of the argument     ```c++    tempalate <typename T>    T && forward(T &&val) {        return val;    }    std::forward<T>(val);     T is int &, then returns val of int & && == val of int & type    T is int, then returns val of int &&;    func(45);  //  T is int, val is rvalue reference to int    do(std::forward<T>(val)) //  std::forward returns val as a rvalue reference type, which is passed to do()```- When ever a template function needs to forward the arguments, std::forward is used to preserve the original type of the arguments.### Overloading templates- amoung the non-template matches and template matches, non-template function is chosen- if there is no non-template matches, amoung the template matches, more specialise one is chosen over the general one- otherwise, the call is ambiguous.- any non-template function overload should be declared before the template, orelse template will instantiate      ```c++    template <typename T>    void print(T &val) {        .../    }    template <typename T>    void print(T *p) {        .../    }    1st template can be called with almost any type, as we can also have a reference to a pointer    2nd template can be called only with pointers    print(num);   //  void print(T &val) instantiated with T as int    print(&num);  //  void print(T &val) with T as int * is instantiated, general version can be called with almost any type                  //  void print(T *p) with T as int is instantiated, more specialised one as it can be called with only pointers.                  //  so void pirn(T *p) instantiation is chosen```            ```c++// More Examples : template <typename T> void f(T); template <typename T> void f(const T*); template <typename T> void g(T); template <typename T> void g(T*); int i = 42, *p = &i; const int ci = 0, *p2 = &ci; a) g(42);    void g(int), T is deduced a int, is instantiated.     As there is no other calls, void g(int) is used with T as int b) g(p);    void g(int *), T is int *, is instantiated     void g(int *), T is int , is instantiated    Both template instantiations provides equally good matches.    When template instantiations provides equally good matches, more specialised version is used    In this case, 1st template can be called with any type, but 2nd template can be called with only pointers.    So instantiation from the 2nd template is used, (ie) void g(T *) with T as int c) g(ci)     void g(int), T is int , is instantiated, top level const ignored    As there is no other calls, void g(int) is used with T as int d) g(p2);    void g(const int *), T is const int *, is instantiated    void g(const int *), T is const int, is instantiated    As Both instantiations provide equally good matches, more specialised one is choosen.    1st template can be called with any type, but 2nd can be called with only pointers.    so 2nd template is used, (ie) void g(T *) with T as const int e) f(42);    void f(int), T is int, is instantiated    void f(int) is used as there is no other overloaded calls f) f(p);    void f(int *), T is int *, is instantiated    void f(const int *), T is int, is instantiated    second version requires const conversion,so void f( int *) is used with T as int * g) f(ci);    void f(int ), T is int, is instantiated.    void f(int ) is used h) f(p2);    void f(const int *), T is const int *, is instantiated.    void f(const int *), T is int is instantiated    more specialised version is used, void f(const T *) is used with T as int.```### VARIADIC TEMPLATES**Variadic Template**, is a template of class or function which can take **varying number** of parameters. The varying number of parameters is called **parameter pack**. **ellipsis...** is used to indicate that the name represents a parameter pack.- typename... indicates that following parameter consists of 0 or more types      - name of type... indicates that following non-type parameter consists of 0 or more non-type parameters of given type      - template parameter pack consists of 0 or more template parameters of same or diff types- function parameter pack consists of 0 or more function parameters of same or diff types```c++    template <typename T, typename... Args>     void print(T &val, Args&... args) {        print(args...);    }    print(num1, d1, str1, f1);     void print(int, double & , string &, float &) is instantiated, T is int, Args... is the parameter pack consisting of types double, string and float deduced from the argument.```**sizeof...(Args) == sizeof...(args)**, is always same they both represents no of elements in the pack    **Expansion of parameter packs**        ellipsis... after the name of the template parameter pack in the function declaration expands the template parameter pack    Anything before the ellipsis... is the pattern that needs to be applied to every element in the pack     ```c++    Args... args  ===  double arg1, string arg2, float arg3         Args&... args ===  double &arg1, string &arg2, float & arg3          const Args*... args === const double *arg1, const string *arg2, const float *arg3     Again args... inside the function expands the function parameter pack.    template <typename T, typename... Args>     void print(T &val, Args&... args) {        print(args...);    }    print(args...) expands the function parameter pack,     1st argument in the pack will be used to deduce T and val will be bound to it.    the rest of the arguments form the template parameter pack Args, which will be expanded again to declare function parameter pack```when a Variadic Template is used recursively, there should be a **non-variadic** overload of the function template with only one parameter, or else the recursion will never stop as when we call print() with function parameter pack containing only one element, T will be bound to that element, and an empty template parameter pack will be deduced, so a function with val bound to arg and empty function parameter pack will be instantiated resulting in a recursion loop.    template <typename T>   //  non-variadic function template    void print(T &val){        .../body    }    this non-variadic template should be declared or defined before the variadic template or else variadic version will be used to instantiate.**Pack expansion :**```c++    print(do(args...));   // expands the pack inside as arguments to the do()    (ie) print(do(arg1, arg2, arg3));    print(do(args)...);   // expands the pack with pattern applied to each element, and the pattern is do(arg)    (ie) print(do(arg1), do(arg2), do(arg3));```### forwarding parameter packs - std::forward is used to forward the parameter pack to another function - to forward first we have declare the function parameter pack using rvalue reference```c++    template <typename... Args>     void print(Args&&... args) {        do_work(std::forward<Args>(args)...);    }     - Args&&... is expanded as Arg1&& arg1, Arg2&& arg2, where argi is the rvalue reference of type Argi    - std::forward<Args>(args)...        expands as std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), std::forward<Argi>(argi)    do_work(std::forward<Args>(args)...) == do_work(std::forward<Arg1>(arg1), std::forward<Argi>(argi));```in-turn we have forwarded all type information to another function.### Template Specialisations **Template Specialisation** is a seperate definition of the original template with all or some parameters of the template are explicitly specified     **template <>**, is used to indicate what follows is a template specialisation     **Function template specialisation**, unlike class templates, these have to explicitly specify all parameters with particular types to specialise, So these are indeed a specific instantiation.      ```c++    template <typename T>   //  original template definition    void func(T a){        .../    }     template <>   //  template specialisation for string type, this will be used when func is called with string.        void func<string>(string a) {        .../    }```overloading affects the function matching where as specialisation doesn't affect function matching**class template specialisation** can specify all or some or part of the parameter.```c++    std::remove_reference is dedined as follows    template <typename T>     struct remove_reference {        typedef T type;    };    template <>    struct remove_reference<T&> {        typedef T type;    };    template <>    struct remove_reference<T&&> {        typedef T  type;    } ```