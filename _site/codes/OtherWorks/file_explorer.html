<!DOCTYPE html>
<html>
    <head>
        <title>First</title>
      <!--  <link href="/assets/css/styles.css" type="text/css" rel="stylesheet">-->
      <link href="/assets/css/styles/github-dark-dimmed.css" type="text/css" rel="stylesheet">
      <script src="/assets/js/highlight.min.js"></script>
      <script>hljs.highlightAll();</script>
    </head>
    <body>
        <nav>
    <ul>
        
        <li><a href="/" >Home</a></li>
        
        <li><a href="/about.html" >About</a></li>
        
        <li><a href="/repository.html" >Repository</a></li>
        
        <li><a href="/solutions.html" >Solutions</a></li>
        
    </ul>
</nav><pre><code class="language-cpp"><xmp>/************************************************************************************************************************************************************
 * @file explorer.cpp
 * @brief code to learn to use std::filesystem
 * @date 2024-03-22
 * 
 * @copyright Copyright (c) 2024
 * 
 *************************************************************************************************************************************************************/

#include <iostream>
#include <filesystem>
#include <fstream>
#include <set>
#include <map>
#include <iomanip>
#include <cstring>
#include <vector>
#include <algorithm>
#include "pause.cpp"

namespace fs = std::filesystem;
 
class Directory {
    friend std::ostream & operator<<(std::ostream &os, Directory &dir);
    public : 
        explicit Directory(const fs::path &curr_, size_t indent_ = 0) : curr(curr_), indent(indent_){
            for(auto iter = fs::directory_iterator(curr); iter != fs::directory_iterator(); ++iter) {
                std::string fname = iter->path().filename();
                if (fs::is_directory(*iter)) {
                        dir_list[iter->path()] = new Directory(iter->path(), indent + 1);
                } else if (fs::is_regular_file(*iter)) { 
                        file_list.insert(iter->path());
                }
            }
        }

        void set_exclude_extension(const std::initializer_list<std::string> &il) {
            for (auto s : il) {
                exclude_extensionlist.insert(s);
            }
        }

        const std::set<std::string> & get_exclude_extensionlist() {
            return exclude_extensionlist;
        }

        void set_exclude_dir(const std::initializer_list<std::string> &il) {
            for (auto s : il) {
                exclude_dirlist.insert(s);
            }
        }

        void set_exclude_file(const std::initializer_list<std::string> &il) {
            for (auto s : il) {
                exclude_filelist.insert(s);
            } 
        }

        const std::set<std::string> & get_exclude_dir() {
            return exclude_dirlist;
        }

        const std::set<std::string> & get_exclude_file() {
            return exclude_filelist;
        }

        void set_exclude_dot_dir(bool val) {
            exclude_dot_dir = val;
        }

        void set_exclude_dot_files(bool val) {
            exclude_dot_files = val;
        }        
 
        ~Directory() {
            for(auto p : dir_list) {
                delete p.second;
            }
        }

        static void merge_files(std::ostream &os, const std::vector<fs::path> &merge_file_list);
        

    private :
        fs::path curr;
        size_t indent;
        std::set<fs::path> file_list;
        std::map<fs::path, Directory *> dir_list;
        static std::string hyperlink(const fs::path &p);
        static std::set<std::string> exclude_dirlist;
        static std::set<std::string> exclude_filelist;
        static std::set<std::string> exclude_extensionlist;
        static bool exclude_dot_dir;
        static bool exclude_dot_files;
        static bool check_exclude_dot_dir(const std::string &fname);
        static bool check_exclude_dot_files(const std::string &fname);
        static bool is_root;
        static std::string add_space(const fs::path &p);
};

std::set<std::string> Directory::exclude_dirlist;
std::set<std::string> Directory::exclude_filelist;
std::set<std::string> Directory::exclude_extensionlist;
bool Directory::exclude_dot_dir = false;
bool Directory::exclude_dot_files = false;
bool Directory::is_root = true;

void Directory::merge_files(std::ostream &os, const std::vector<fs::path>& merge_file_list){
    os << std::endl;
    for (auto& p : merge_file_list) {
        std::ifstream ifile(p);
        if (!ifile) {
            std::cout << "unable to open file" << p.filename() << std::endl;
        }
        std::string line; 
        while (getline(ifile, line)) {
            os << line << std::endl;
        }
    }
}

std::string Directory::add_space(const fs::path &p) {
    size_t min_len = 20;
    size_t len = strlen(p.filename().c_str());
    if (len < min_len) {
        return std::string(min_len - len, ' ');
    }
    return std::string();
} 

std::string Directory::hyperlink(const fs::path &p) {
    return std::string("<a href = \"") + std::string(fs::relative(p)).substr(2) + "\">" + std::string(p.filename()) + "</a>";
}

bool Directory::check_exclude_dot_dir(const std::string &fname) {
    if (exclude_dot_dir) {
        if (fname[0] == '.') {
            return true;
        } else {
            return false;
        }
    } 
    return false;
}

bool Directory::check_exclude_dot_files(const std::string &fname) {
    if (exclude_dot_files) {
        if (fname[0] == '.') {
            return true;
        } else {
            return false;
        }
    } 
    return false;
}

std::ostream & operator<<(std::ostream &os, Directory &dir) {
    std::string indent_str("&nbsp;");
    for (size_t i = 0; i < dir.indent * 3; ++i) {
        indent_str += indent_str;
    }

    size_t file_cnt = 0;
    size_t dir_cnt = 0;
    os << std::endl;
    if (dir.file_list.size()) {
        os << "|   |   |   |   |   |   |" << std::endl;
        os << "|---|---|---|---|---|---|" << std::endl;
    }    
    for (auto p : dir.file_list) {
        if (dir.exclude_filelist.find(p.filename()) == dir.exclude_filelist.end() 
            && dir.exclude_extensionlist.find(p.extension()) == dir.exclude_extensionlist.end()
            && !Directory::check_exclude_dot_files(p.filename().c_str())) {     
            os << "| " << dir.hyperlink(p);  
            if (file_cnt == 5) {
                os << " |        ";
                file_cnt = 0;
                os << std::endl;
            } else {
                ++file_cnt;
            }
        }    
    } 
    if (file_cnt) {
        while (file_cnt <= 6) {
            os << " |      ";
            ++file_cnt; 
        }
        os << std::endl; 
    }
     
    for (auto p : dir.dir_list) {   
        if (dir.exclude_dirlist.find(p.first.filename()) == dir.exclude_dirlist.end() && !Directory::check_exclude_dot_dir(p.first.filename().c_str())) {
            os << "<details><summary>" << dir.hyperlink(p.first) << "</summary>"<< std::endl;
            os << *p.second;
            os << "</details>";
        }        
    }

    return os;
}    

int main() {
    std::ofstream ofile("/home/vijai/github/c++primer/readme    .md", std::ios_base::app);
    
    fs::path curr("/home/vijai/github/c++primer");
    std::cout << "displaying contents of : " << curr << std::endl;
    Directory d1(curr);
    d1.set_exclude_extension({".exe",".out"});
    d1.set_exclude_file({"rooster"});
    d1.set_exclude_dot_dir(true);
    d1.set_exclude_dot_files(true);
    d1.set_exclude_dir({"DBMS","OtherWorks","docs"});
    ofile << d1 << std::endl;
    
    d1.merge_files(ofile, {fs::path("/home/vijai/github/c++primer/DBMS/readme.md")});
    d1.merge_files(ofile, {fs::path("/home/vijai/github/c++primer/OtherWorks/readme.md")}); 
    
    return 0;
}
</xmp></code></pre>